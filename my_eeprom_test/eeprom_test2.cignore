/**************************************************************************
 *  XC-2000 IO-LIB
 *  Test Module
 **************************************************************************
 *  EEPROM driver
 *
 *  Writes data to EEPROM an reads it back again
 *
 **************************************************************************/

#include "IO_Driver.h"
#include "IO_EEPROM.h"
#include "IO_ADC.h"
#include "IO_DIO.h"
#include "IO_RTC.h"
#include "APDB.h"

APDB appl_db =
          { 0                      /* ubyte4 versionAPDB        */
          , {0}                    /* BL_T_DATE flashDate       */
                                   /* BL_T_DATE buildDate                   */
          , { (ubyte4) (((((ubyte4) RTS_TTC_FLASH_DATE_YEAR) & 0x0FFF) << 0) |
                        ((((ubyte4) RTS_TTC_FLASH_DATE_MONTH) & 0x0F) << 12) |
                        ((((ubyte4) RTS_TTC_FLASH_DATE_DAY) & 0x1F) << 16) |
                        ((((ubyte4) RTS_TTC_FLASH_DATE_HOUR) & 0x1F) << 21) |
                        ((((ubyte4) RTS_TTC_FLASH_DATE_MINUTE) & 0x3F) << 26)) }
          , 0                      /* ubyte4 nodeType           */
          , 0                      /* ubyte4 startAddress       */
          , 0                      /* ubyte4 codeSize           */
          , 0                      /* ubyte4 legacyAppCRC       */
          , 0                      /* ubyte4 appCRC             */
          , 1                      /* ubyte1 nodeNr             */
          , 0                      /* ubyte4 CRCInit            */
          , 0                      /* ubyte4 flags              */
          , 0                      /* ubyte4 hook1              */
          , 0                      /* ubyte4 hook2              */
          , 0                      /* ubyte4 hook3              */
          , APPL_START             /* ubyte4 mainAddress        */
          , {0, 1}                 /* BL_T_CAN_ID canDownloadID */
          , {0, 2}                 /* BL_T_CAN_ID canUploadID   */
          , 0                      /* ubyte4 legacyHeaderCRC    */
          , 0                      /* ubyte4 version            */
          , 500                    /* ubyte2 canBaudrate        */
          , 0                      /* ubyte1 canChannel         */
          , {0}                    /* ubyte1 reserved[8*4]      */
          , 0                      /* ubyte4 headerCRC          */
          };

IO_ErrorType beforeADC();
IO_ErrorType afterADC();
 
void main (void)
{
    ubyte1 data[2000] = {0};
    // State data
    ubyte1 state1 = 0xFF;
    ubyte1 state2 = 0x88;
    ubyte1 state3 = 0x11;

    ubyte1 state = 0;
    ubyte4 timestamp;
    // Analog Input from POT
    ubyte1 write_channel = IO_ADC_5V_04;
    // Digital Output from LED
    ubyte1 read_channel = IO_DO_04;

    IO_ErrorType newWrite;
    IO_ErrorType oldWrite;

    bool write_light = FALSE;
    bool read_light = FALSE;
    // Tracks ADC value as new or old
    bool refresh = FALSE;

    IO_Driver_Init( NULL );

    // // WRITE LIGHT
    // // Output channel for Motor Fan 
    // // Pin 144
    // IO_DO_Init( write_channel );

    // // Output channel for Motor Fan 
    // // Pin 144
    // IO_DO_DeInit( write_channel );

    // // READ LIGHT
    // // Output channel for RTDS
    // // Pin 131
    // IO_DO_Init( read_channel );

    // // Output channel for RTDS
    // // Pin 131
    // IO_DO_DeInit( read_channel );

    // pin 150
    // Resistive input POT
    IO_ADC_ChannelInit( write_channel
                      , IO_ADC_RESISTIVE
                      , IO_ADC_RANGE_15V
                      , IO_ADC_PU_10K
                      , IO_SENSOR_SUPPLY_VAR
                      , NULL );

    // pin 150
    // Resistive input POT
    IO_ADC_ChannelDeInit( write_channel );

    // Writing F for min resistance
    // state = 1;
    // Writing F/2 for mid resistance
    // state = 2;
    // Writing 0 for max resistance
    // state = 3;

    // TODO
    // 1 read the EEPROM values from hardware
    // 2 hardware transferred to cache
    // 3 cache manipulates that data "Hello"
    // 4 cache transfers to hardware EEPROM

    while(1)
    {
        IO_RTC_StartTime(&timestamp);

        IO_Driver_TaskBegin();

        state += 1;
        refresh = FALSE;

        oldWrite = IO_ADC_Get( write_channel
                  , IO_ADC_RESISTIVE
                  , &refresh );

        if (IO_EEPROM_GetStatus() == IO_E_OK)
        {
          switch(state)
          {
            case 1: IO_EEPROM_Write(0, 2, &state1); break;
            case 2: IO_EEPROM_Write(0, 2, &state2); break;
            case 3: IO_EEPROM_Write(0, 2, &state3); break;
            default: break;
          }
          refresh = TRUE;
        }        

        newWrite = IO_ADC_Get( write_channel
                  , IO_ADC_RESISTIVE
                  , &refresh );

        IO_Driver_TaskEnd();
    }
}



IO_ErrorType beforeADC()
{
  return IO_E_OK;
}
IO_ErrorType afterADC()
{
  return IO_E_OK;
}